from kmos.io import _chop_line
from copy import deepcopy

lat_int_groups = self._get_lat_int_groups()

#@ module proclist
#@
#@ use kind_values
#@ use proclist_constants
#@
#@ use lattice, only: &
#@     spuck, &
#@     system_size, &
#@     nr2lattice, &
#@     add_proc, &
#@     del_proc, &
#@     change_proc, &
#@     get_species
#@
#@ use base, only: &
#@     update_accum_rate, &
#@     update_integ_rate, &
#@     determine_procsite, &
#@     update_clocks, &
#@     avail_sites, &
#@     null_species, &
#@     increment_procstat
#@
for i in range(len(lat_int_groups)):
    #@ use nli_{i:04d}
#@
#@ implicit none
#@

#@ integer(kind=iint), public :: seed_size = 12
#@ integer(kind=iint), public :: seed ! random seed
#@ integer(kind=iint), public, dimension(:), allocatable :: seed_arr ! random seed
#@
#@
#@ contains
#@
#@ subroutine run_proc_nr(proc, nr_cell)
#@     integer(kind=iint), intent(in) :: nr_cell
#@     integer(kind=iint), intent(in) :: proc
#@ 
#@     integer(kind=iint), dimension(4) :: cell
#@ 
#@     cell = nr2lattice(nr_cell, :) + (/0, 0, 0, -1/)
if data.meta.debug > 1:
    #@ print *, "PROCLIST/RUN_PROC_NR/PROC", proc, "NR_CELL", nr_cell
    #@ print *, "PROCLIST/RUN_PROC_NR/CELL", cell
#@     call increment_procstat(proc)
#@ 
#@     select case(proc)
for lat_int_group, processes in lat_int_groups.iteritems():
    proc_names = ', '.join([proc.name for proc in processes])
    chopped_line = _chop_line(proc_names, line_length=60)
    #@     case({chopped_line})
    if data.meta.debug > 1 :
        #@ print *, "PROCLIST/RUN_PROC_{lat_int_group}/CELL", cell
    #@         call run_proc_{lat_int_group}(cell)
#@     case default
#@         print *, "Whoops, should not get here!"
#@         print *, "PROC_NR", proc
#@         stop
#@     end select
#@ 
#@ end subroutine run_proc_nr
#@

#@ subroutine do_kmc_steps(n)
#@ 
#@ !****f* proclist/do_kmc_steps
#@ ! FUNCTION
#@ !    Performs ``n`` kMC step.
#@ !    If one has to run many steps without evaluation
#@ !    do_kmc_steps might perform a little better.
#@ !    * first update clock
#@ !    * then configuration sampling step
#@ !    * last execute process
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    ``n`` : Number of steps to run
#@ !******
#@     integer(kind=iint), intent(in) :: n
#@ 
#@     real(kind=rsingle) :: ran_proc, ran_time, ran_site
#@     integer(kind=iint) :: nr_site, proc_nr, i
#@ 
#@     do i = 1, n
if data.meta.debug > 1:
    #@ print *, "PROCLIST/DO_KMC_STEP/N", n
#@     call random_number(ran_time)
#@     call random_number(ran_proc)
#@     call random_number(ran_site)
if data.meta.debug > 1:
    #@ print *, "PROCLIST/DO_KMC_STEP/RAND", ran_time, ran_proc, ran_site
#@     call update_accum_rate
#@     call update_clocks(ran_time)
#@ 
#@     call update_integ_rate
#@     call determine_procsite(ran_proc, ran_site, proc_nr, nr_site)
if data.meta.debug > 1:
    #@ print *, "PROCLIST/DO_KMC_STEP/PROC", proc_nr, "SITE", nr_site
#@     call run_proc_nr(proc_nr, nr_site)
#@     enddo
#@ 
#@ end subroutine do_kmc_steps
#@
#@ subroutine get_next_kmc_step(proc_nr, nr_site)
#@ 
#@ !****f* proclist/get_kmc_step
#@ ! FUNCTION
#@ !    Determines next step without executing it.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    ``none``
#@ !******
#@     real(kind=rsingle) :: ran_proc, ran_time, ran_site
#@     integer(kind=iint), intent(out) :: nr_site, proc_nr
#@ 
#@     call random_number(ran_time)
#@     call random_number(ran_proc)
#@     call random_number(ran_site)
#@     call update_accum_rate
#@     call determine_procsite(ran_proc, ran_time, proc_nr, nr_site)
#@ 
#@ end subroutine get_next_kmc_step
#@ 
#@ subroutine get_occupation(occupation)
#@     !****f* proclist/get_occupation
#@     ! FUNCTION
#@     !    Evaluate current lattice configuration and returns
#@     !    the normalized occupation as matrix. Different species
#@     !    run along the first axis and different sites run
#@     !    along the second.
#@     !
#@     ! ARGUMENTS
#@     !
#@     !    ``none``
#@     !******
site_params = self._get_site_params()
len_species_list_p1 = len(data.species_list) + 1
len_species_list_m1 = len(data.species_list) - 1
len_species_list = len(data.species_list)
len_site_params = len(site_params)
if len(data.layer_list) > 1 :  # multi-lattice mode
    #@     ! nr_of_species = {len_species_list_p1}, spuck = {len_site_params}
else:
    #@     ! nr_of_species = {len_species_list}, spuck = {len_site_params}
#@     ! nr_of_species = 3, spuck = 1
#@     real(kind=rdouble), dimension(0:{len_species_list_m1}, 1:{len_site_params}), intent(out) :: occupation
#@     
#@     integer(kind=iint) :: i, j, k, nr, species
#@     
#@     occupation = 0
#@     
#@     do k = 0, system_size(3)-1
#@         do j = 0, system_size(2)-1
#@             do i = 0, system_size(1)-1
#@                 do nr = 1, spuck
#@                     ! shift position by 1, so it can be accessed
#@                     ! more straightforwardly from f2py interface
#@                     species = get_species((/i,j,k,nr/))
#@                     if(species.ne.null_species) then
#@                     occupation(species, nr) = &
#@                         occupation(species, nr) + 1
#@                     endif
#@                 end do
#@             end do
#@         end do
#@     end do
#@     
#@     occupation = occupation/real(system_size(1)*system_size(2)*system_size(3))
#@     
#@ end subroutine get_occupation
#@     


for lat_int_group, processes in lat_int_groups.iteritems():
    #@ subroutine run_proc_{lat_int_group}(cell)
    #@     integer(kind=iint), dimension(4), intent(in) :: cell
    #@     integer(kind=iint), dimension(4) :: in_cell
    #@     integer(kind=iint) :: stored_proc
    #@
    #@     in_cell = cell + (/0, 0, 0, 1/)
    process = processes[0]
    for action in process.action_list:
        new_species = action.species
        old_species = [c for c in process.condition_list if action.coord == c.coord][0].species
        rel_action_coord = action.coord.radd_ff('cell')
        action_coord = str(action.coord)
        #@
        if data.meta.debug > 1 :
            #@ print *, "PROCLIST/RUN_PROC_{lat_int_group}/ACTION_COORD {action_coord}"
            #@ print *, "PROCLIST/RUN_PROC_{lat_int_group}/REL_ACTION_COORD", {rel_action_coord}
            #@ print *, "PROCLIST/RUN_PROC_{lat_int_group}/OLD_SPECIES {old_species}"
            #@ print *, "PROCLIST/RUN_PROC_{lat_int_group}/NEW_SPECIES {new_species}"
        #@     call replace_species({rel_action_coord}, {old_species}, {new_species})
        for other_lat_int_group, other_processes in lat_int_groups.iteritems():
            other_process = other_processes[0]

            for i_other_condition, other_condition in enumerate(other_process.condition_list):
                if other_condition.coord.name == action.coord.name :
                    rel_condition_coord = (action.coord - other_condition.coord).radd_offset('in_cell')
                    rel_condition_cell = (action.coord - other_condition.coord).radd_offset('cell')
                    if other_condition.species == old_species and other_condition.species != new_species:
                        if data.meta.debug > 1:
                            #@ print *,"PROCLIST/DEL_PROC/PROC {other_lat_int_group}", {rel_condition_coord}
                        #@     call del_proc({other_lat_int_group}, {rel_condition_coord})
                    elif other_condition.species != old_species and other_condition.species == new_species:
                        if data.meta.debug > 1:
                            #@ print *,"PROCLIST/ADD_PROC/PROC {other_lat_int_group} {rel_condition_coord}"
                        #@     !call add_proc({other_lat_int_group}, {rel_condition_coord})
                        #@     call add_proc(nli_{other_lat_int_group}({rel_condition_cell}), {rel_condition_coord})
                    elif other_condition.species != old_species and other_condition.species != new_species:
                        pass
                    else:
                        raise Exception('Check for logical error in your model: old_species(%s) vs. new_species(%s), Condition %s' %
                                        (old_species, new_species, other_condition.species))
            if other_process.bystanders : #  process with lateral interaction
                #@
                #@     ! bystander updates
                for i_other_condition, other_condition in enumerate(other_process.bystanders):
                    if other_condition.coord.name == action.coord.name :
                        rel_condition_coord = other_condition.coord.rsub_offset('in_cell')
                        allowed_species = list(set([(other_process2.bystanders)[i_other_condition].species
                                           for other_process2 in other_processes]))
                        #################
                        # four cases
                        #################
                        if old_species in allowed_species and new_species in allowed_species:
                            # TODO FIXME: this is not the criterion that is valid here !!!
                            # Either allowed species are not selected correctly
                            # or we need to do something completely different here.
                            old_procs = [other_process2 for other_process2 in other_processes
                                         if (other_process2.bystanders)[i_other_condition].species == old_species
                                        ]
                            not_old_procs = [other_process2 for other_process2 in other_processes
                                         if (other_process2.bystanders)[i_other_condition].species != old_species
                                        ]
                            new_procs = []
                            for old_proc in old_procs:
                                conditions = deepcopy(old_proc.bystanders)
                                conditions[i_other_condition].species = new_species
                                new_proc_candidates = [
                                    new_proc for new_proc in other_processes if
                                    conditions == (new_proc.bystanders)
                                ]
                                new_procs.append(new_proc_candidates[0])

                            if not len(old_procs) == len(new_procs):
                                raise Exception(("Number of possible old"
                                                 " and new procs differs: %s vs %s") \
                                                 % (len(old_procs), len(new_procs)))

                            #@
                            #@     stored_proc = get_stored_proc({other_lat_int_group}, {rel_condition_coord})
                            if data.meta.debug > 1 :
                                #@             print *, "        PROCLIST/run_proc_{lat_int_group}/COORD", {rel_condition_coord}
                                #@             print *, "        PROCLIST/run_proc_{lat_int_group}/STORED_PROC", stored_proc
                            #@     select case(stored_proc)
                            #@         case(0) ! nothing stored, go figure
                            ##@             call add_proc(nli_{other_lat_int_group}({rel_condition_cell}), {rel_condition_coord})
                            not_old_proc_names = _chop_line(', '.join(
                                not_old_proc.name for not_old_proc in not_old_procs
                                ).replace('\n', ''), line_length=60)
                            # #@         case({not_old_proc_names}) ! must be dealt with elsewhere
                            for old_proc, new_proc in zip(old_procs, new_procs):
                                old_proc_name = old_proc.name
                                new_proc_name = new_proc.name
                                #@         case({old_proc_name})
                                #@             call change_proc({old_proc_name}, {new_proc_name}, {rel_condition_coord})
                            #@         case default
                            #@             print *, "PROCLIST/run_proc_{lat_int_group}/STORED_PROC", stored_proc
                            #@             print *, "Should not get there! # {_line_nr}"
                            #@             stop
                            #@     end select
                        elif old_species in allowed_species and new_species not in allowed_species:
                            pass #  disable (more), easy
                            #@     call del_proc({other_lat_int_group}, {rel_condition_coord})
                        elif not old_species in allowed_species and new_species in allowed_species:
                            pass #  enable (more), easy
                            #@     call add_proc(nli_{other_lat_int_group}({rel_condition_cell}), {rel_condition_coord})
                            # FIXME
                        elif not old_species in allowed_species and new_species not in allowed_species:
                            pass #  do nothing, trivial
            else:
                # Simple process, treat later
                pass
    if data.meta.debug > 1 :
        #@ print *, "PROCLIST/RUN_PROC_{lat_int_group}/FINISHED"
    #@
    #@ end subroutine run_proc_{lat_int_group}
    #@
    #@


# Here we replicate the allocate_system call, initialize
# all book-keeping databases
# and calculate the rate constants for the first time
model_name_line = ('This kMC Model \'%s\' was written by' % data.meta.model_name).ljust(59)
author_name_line = ('%s (%s)' % (data.meta.author, data.meta.email)).center(60)
#@ subroutine allocate(input_system_size, system_name, layer, seed_in, no_banner)
#@
#@ !****f* proclist/init
#@ ! FUNCTION
#@ !     Allocates the system and initializes all sites in the given
#@ !     layer.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``input_system_size`` number of unit cell per axis.
#@ !    * ``system_name`` identifier for reload file.
#@ !    * ``layer`` initial layer.
#@ !    * ``no_banner`` [optional] if True no copyright is issued.
#@ !******
#@     integer(kind=iint), intent(in) :: layer, seed_in
#@     integer(kind=iint), dimension({data.meta.model_dimension}), intent(in) :: input_system_size
#@
#@     character(len=400), intent(in) :: system_name
#@
#@     logical, optional, intent(in) :: no_banner
#@
#@     if (.not. no_banner) then
#@         print *, "+------------------------------------------------------------+"
#@         print *, "|                                                            |"
#@         print *, "| {model_name_line}|"
#@         print *, "|                                                            |"
#@         print *, "|{author_name_line}|"
#@         print *, "|                                                            |"
#@         print *, "| and implemented with the help of kmos,                     |"
#@         print *, "| which is distributed under GNU/GPL Version 3               |"
#@         print *, "| (C) Max J. Hoffmann mjhoffmann@gmail.com                   |"
#@         print *, "|                                                            |"
#@         print *, "| kmos is distributed in the hope that it will be useful     |"
#@         print *, "| but WIHTOUT ANY WARRANTY; without even the implied         |"
#@         print *, "| waranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     |"
#@         print *, "| PURPOSE. See the GNU General Public License for more       |"
#@         print *, "| details.                                                   |"
#@         print *, "|                                                            |"
#@         print *, "| If using kmos for a publication, attribution is            |"
#@         print *, "| greatly appreciated.                                       |"
#@         print *, "| Hoffmann, M. J., Matera, S., & Reuter, K. (2014).          |"
#@         print *, "| kmos: A lattice kinetic Monte Carlo framework.             |"
#@         print *, "| Computer Physics Communications, 185(7), 2138-2150.        |"
#@         print *, "|                                                            |"
#@         print *, "| Development http://mhoffman.github.org/kmos                |"
#@         print *, "| Documentation http://kmos.readthedocs.org                  |"
#@         print *, "| Reference http://dx.doi.org/10.1016/j.cpc.2014.04.003      |"
#@         print *, "|                                                            |"
#@         print *, "+------------------------------------------------------------+"
#@         print *, ""
#@         print *, ""
#@     endif

if data.meta.debug > 0:
    #@ print *,"PROCLIST/INIT"
    #@ print *,"    PROCLIST/INIT/SYSTEM_SIZE",input_system_size
if len(data.layer_list) > 1 :
    #@     call set_null_species(null_species)
#@     call allocate_system(nr_of_proc, input_system_size, system_name)
if data.meta.debug > 0:
    #@ print *,"    PROCLIST/INIT/ALLOCATED_LATTICE"
#@ end subroutine allocate
#@

# initialize the system with the default layer and the default species
# initialize all book-keeping databases
# and representation strings for ASE representation
#@ subroutine initialize_state(layer, seed_in)
#@
#@ !****f* proclist/initialize_state
#@ ! FUNCTION
#@ !    Initialize all sites and book-keeping array
#@ !    for the given layer.
#@ !
#@ ! ARGUMENTS
#@ !
#@ !    * ``layer`` integer representing layer
#@ !******
#@     integer(kind=iint), intent(in) :: layer, seed_in
#@
#@     integer(kind=iint) :: i, j, k, nr
if data.meta.debug > 0:
    #@ print *,"PROCLIST/INITIALIZE_STATE"
#@     ! initialize random number generator
#@     allocate(seed_arr(seed_size))
#@     seed = seed_in
#@     seed_arr = seed
#@     call random_seed(seed_size)
#@     call random_seed(put=seed_arr)
#@     deallocate(seed_arr)
if data.meta.debug > 0:
    #@ print *, "    PROCLIST/INITALIZE_STATE/INITIALIZED_RNG"
#@     do k = 0, system_size(3)-1
#@         do j = 0, system_size(2)-1
#@             do i = 0, system_size(1)-1
#@                 do nr = 1, spuck
#@                     call reset_site((/i, j, k, nr/), null_species)
#@                 end do
#@                 select case(layer)
for layer in data.layer_list:
    #@                 case ({layer.name})
    for site in layer.sites:
        #@                     call replace_species((/i, j, k, {layer.name}_{site.name}/), null_species, {site.default_species})
#@                 end select
#@             end do
#@         end do
#@     end do
#@
if data.meta.debug > 0:
    #@ print *, "    PROCLIST/INITALIZE_STATE/INITIALIZED_DEFAULT_SPECIES"
#@     do k = 0, system_size(3)-1
#@         do j = 0, system_size(2)-1
#@             do i = 0, system_size(1)-1
if data.meta.debug > 0:
    #@ print *, "    PROCLIST/INITIALIZE_STATE/TOUCHUP_CELL", i, j, k
#@                 call touchup_cell((/i, j, k, 0/))
#@             end do
#@         end do
#@     end do
#@
if data.meta.debug > 0:
    #@ print *, "    PROCLIST/INITALIZE_STATE/INITIALIZED_AVAIL_SITES"
    #@ print *,"    PROCLIST/INIT/INITIALIZED_STATE"
#@
#@ end subroutine initialize_state
#@

#@ subroutine touchup_cell(cell)
#@     integer(kind=iint), intent(in), dimension(4) :: cell
#@     integer(kind=iint), dimension(4) :: site
#@
#@     integer(kind=iint) :: proc_group, stored_proc, nli
#@     site = cell + (/0, 0 , 0, 1/)
if data.meta.debug > 1:
    #@ print *, "    PROCLIST/TOUCHUP_CELL/CELL", cell
    #@ print *, "    PROCLIST/TOUCHUP_CELL/SITE", site
#@
#@     do proc_group = 1, nr_of_proc_groups
#@         stored_proc = get_stored_proc(proc_group, site)
if data.meta.debug > 1:
    #@ print *, "    PROCLIST/TOUCHUP_CELL/PROC_GROUP", proc_group
    #@ print *, "    PROCLIST/TOUCHUP_CELL/STORED_PROC", stored_proc
#@         if(stored_proc>0) then
if data.meta.debug > 0:
    #@ print *, "    PROCLIST/TOUCHUP_CELL/DELETE_PROC", stored_proc
#@             call del_proc(stored_proc, site)
#@         endif
#@     end do
#@

for lat_int_group, process in lat_int_groups.iteritems():
    #@     nli = nli_{lat_int_group}(cell)
    if data.meta.debug > 0:
        #@ print *, "    PROCLIST/TOUCHUP_CELL/ADD_PROC_GROUP {lat_int_group}", proc_groups({lat_int_group})
        #@ print *, "    PROCLIST/TOUCHUP_CELL/NLI_{lat_int_group}", nli
    #@     call add_proc(nli_{lat_int_group}(cell), site)
#@ end subroutine touchup_cell
#@


#@ end module proclist
